'''Программа для расчета ядерной и электронной тормозных способностей ионов при ионной имплантации в соответствии с заданными условиями.
С помощью метода диффузионного приближения рассчитывается проецированный пробег и разброс проецированных пробегов.
Для полученных значений рассчитывается также гауссовский профиль профиль распределения примеси и отображается в виде графика'''

import numpy as np
import math as mt
import matplotlib.pyplot as plt

#Константы
N = 1000
#aem = 1.67e-27
q = 1.6e-19
epsilon_0 = 8.85e-14
p = 0.005
q2=1.44e-7

a0 = 0.529e-7
a1 = 1.1383
b1 = 0.01321
d1 = 0.19593
c1 = 0.21226

#Параметры арсенида галия
m2 = (69.72 + 74.92) / 2 #* aem
z2 = (31 + 33) / 2
#Параметры серы
m1 = 32.06# * aem
z1 = 16
#Значение энергии и дозы
E = 150000 # ev
Q = 1e15

a = 0.8854 * a0 / ((z1 ** 0.66 + z2 ** 0.66)) ** 0.5


#шаг энергии
dE = E / N

Rp = np.zeros(N + 1)
Csi = np.zeros(N + 1)
dRpl = np.zeros(N + 1)

#Проецированный пробег
for i in range(1, N + 1):
    E = dE*i
    eps = (a * m2 * E) / (z1 * z2 * q2 * (m1 + m2))

    # Условие для расчета ядерной тормозной в зависимости от эпислона
    if eps < 10:
        sn_0 = mt.log(1 + a1 * eps) / (2 * (eps + b1 * eps ** c1 + d1 * eps ** 0.5))
    else:
        sn_0 = mt.log(eps) / (2 * eps)

    # Перерасчет ядерной тормозной
    Sn = (8.462E-15 * z2 * z1 * m1 * sn_0) / ((m2 + m1) * (z2 ** 0.23 + z1 ** 0.23)) * 4.42E22

    # Коэффициент Линхарда Cr и Ce
    k1 = z1 ** (1 / 6) * 0.0793 * z1 ** (1 / 2) * (m1 + m2) ** (3 / 2) / ((z2 ** (2 / 3) + z1 ** (2 / 3)) ** (3 / 4) * m1 ** (3 / 2) * m2 ** (1 / 2))
    Cr = (4 * 3.14 * a ** 2 * m1 * m2) / (m1 + m2) ** 2
    Ce = 4 * 3.1416 * a * m2 / (z1 * z2 * q2 * (m1 + m2))

    # Коэффициент пропорциональности и электронная тормозная
    k = k1 * Cr / Ce ** 0.5
    Se = (k * i ** 0.5) * 4.42E22

    Rp[i] = Rp[i - 1] + (1 - (m2 / m1) * (Sn / (Sn + Se)) * (dE / E)) * (dE / (Sn + Se))
#Кси для расчета разброса
    Csi[i] = Csi[i - 1] + (2 * Rp[N] / (Se + Sn)) * dE
#Базовый разброс проецированного пробега
    dRpl[i] = (dRpl[i - 1] ** 2 + (Csi[N] - 2 * dRpl[i - 1] ** 2) * (m2 / m1) * (Sn / (Sn + Se)) * (dE / E)) ** 0.5

x = np.zeros(N + 1)
print(Csi[N],' ',Rp[N],' ',dRpl[N])
dRp = mt.fabs(Csi[N] - Rp[N] ** 2 - dRpl[N] ** 2) ** 0.5

x2 = np.zeros(N + 1)

dx = p / N

x[0] = 0
x2[0] = 0

for i in range (1, N + 1):
    x[i] = x[i - 1] + dx
    x2[i] = x[i] / 1e-4 # mkm

C = np.zeros(N + 1)

#Расчет распределения для графика
for i in range (0, N + 1):
    C[i] = Q / ((2 * 3.1415) ** 0.5 * dRp) * mt.exp(-(x[i] - Rp[N]) ** 2 / (2 * dRp ** 2))

plt.plot(x2, C)
plt.xlabel('Глубина, мкм')
plt.ylabel('Концентрация, см-3')
plt.show()